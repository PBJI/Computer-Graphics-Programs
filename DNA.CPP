#include<iostream.h>
#include<graphics.h>
#include<conio.h>
#include<math.h>

#define PI 3.1415927;

int main() {
	int graphicsDriver=DETECT, graphicsMode;
	initgraph(&graphicsDriver, &graphicsMode, "C:\\TURBOC3\\BGI");
	//DNA requires two helical curves parallel with a little different phase.
	//
	//It will be easier to draw the helical curves if confine it inside a
	//rectangular boundary.
	//
	//It will be also easier to draw in a particular direction like
	//Horizontally.
	//
	//DNA would also require coplanar lines that are perpendicular to the
	//direction of the DNA curves.
	//
	//If we translate a helical curve into 2D it represents a sine way.
	//
	//So why not use two sine waves with two different phase. One will be
	//relatively ahead of the other one. In short we will keep the theta
	//constant and just add a shift value to one sine way.
	//
	//We will keep the Y constant and X as the direction of the DNA
	//
	//We will create an array that will store the two sine values for
	//each Y-axis
	//
	//We will create an algorithm that will generate lines based of those
	//two values from the matrix generated by the sine wave algorithm.
	//
	//The length of the DNA would go from 0 to MAX_X
	//
	//The width value will be appromixated with some trial and error.
	//Depending upon what suits our imagination.
	//
	//Frequency, which means the number of waves that should be generated
	//will also be experimented and then deliberated upon. In terms of the
	//program algorithm, basically the ratio of radians upon number of pixels
	//will deliberated upon.
	int MAX_X = getmaxx();
	//TO BE FIXED: (Size of array should be constant during compilation
	//but we need an array that is dynamically defined during runtime.)
	//Solution lies somewhere in heap vs stack concept.
	//int dnaCurves[2][MAX_X];

	double oneWave = PI;
	double phaseAngle = oneWave / 2;
	double totalAngle = oneWave * 5; // 5 waves for now



	getch();
	closegraph();
	//Printing some information after this lines to enable debugging and
	//for testing purposes after the graph is closed.
	//Tested for a single value of y here on x = 50 with 25 as amplitude
	//A bit of casting is going here but overlook the complexity of it.
	cout << (int) (25 * sin(totalAngle * ( (double) 50 / (double) MAX_X )));
	//cout << endl << MAX_X;
	//cout << endl << totalAngle;
	getch();
	return 0;
}