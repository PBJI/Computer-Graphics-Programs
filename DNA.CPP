#include<iostream.h>
#include<graphics.h>
#include<conio.h>
#include<math.h>

#define PI 3.1415927;

int main() {
	int graphicsDriver=DETECT, graphicsMode;
	initgraph(&graphicsDriver, &graphicsMode, "C:\\TURBOC3\\BGI");

	//Some brainstorming on the idea:
	//DNA requires two helical curves parallel with a little different phase.
	//
	//It will be easier to draw the helical curves if confine it inside a
	//rectangular boundary.
	//
	//It will be also easier to draw in a particular direction like
	//Horizontally.
	//
	//DNA would also require coplanar lines that are perpendicular to the
	//direction of the DNA curves.
	//
	//If we translate a helical curve into 2D it represents a sine way.
	//
	//So why not use two sine waves with two different phase. One will be
	//relatively ahead of the other one. In short we will keep the theta
	//constant and just add a shift value to one sine way.
	//
	//We will keep the Y constant and X as the direction of the DNA
	//
	//We will create an array that will store the two sine values for
	//each Y-axis
	//
	//We will create an algorithm that will generate lines based of those
	//two values from the matrix generated by the sine wave algorithm.
	//
	//The length of the DNA would go from 0 to MAX_X
	//
	//The width value will be appromixated with some trial and error.
	//Depending upon what suits our imagination.
	//
	//Frequency, which means the number of waves that should be generated
	//will also be experimented and then deliberated upon. In terms of the
	//program algorithm, basically the ratio of radians upon number of pixels
	//will deliberated upon.



	//Upcoming features:
	//Thickness of the DNA
	//Colorful Strands
	int MAX_X = getmaxx();
	//TO BE FIXED: (Size of array should be constant during compilation
	//but we need an array that is dynamically defined during runtime.)
	//Solution lies somewhere in heap vs stack concept.
	//int dnaCurves[2][MAX_X];

	double oneWave = PI;
	double phaseAngle = oneWave / 2;
	double waves = 8;						 //Experimental
	double totalAngle = oneWave * waves; // 5 waves for now
	double amplitude = 20;					 //Experimental
	int shiftY = getmaxy() / 2;			   	 //Experimental
	int linesPerWave = 10; //DNA protein AGDT lines count
	int xpixPerWave = (double) MAX_X / waves;
	int spacePerLine = xpixPerWave / linesPerWave;

	for (int x = 0; x < MAX_X; x++) {
		double currentY1Angle = totalAngle * ((double) x / (double) MAX_X);
		double currentY2Angle = currentY1Angle + phaseAngle;
		double Y1 = amplitude * sin(currentY1Angle);
		double Y2 = amplitude * sin(currentY2Angle);
		putpixel(x, Y1 + shiftY, WHITE);
		putpixel(x, Y2 + shiftY, WHITE);
		if ( x % spacePerLine == 0 ) {
			line(x, Y1 + shiftY, x, Y2 + shiftY);
			setcolor(WHITE);
		}
		//Debugging line:
		//cout << x << " " << Y1 << " " << Y2 << endl;
	}


	getch();
	closegraph();
	//Printing some information after this lines to enable debugging and
	//for testing purposes after the graph is closed.
	//Tested for a single value of y here on x = 50 with 25 as amplitude
	//A bit of casting is going here but overlook the complexity of it.
	cout << (int) (25 * sin(totalAngle * ( (double) 50 / (double) MAX_X )));
	//cout << endl << MAX_X;
	//cout << endl << totalAngle;
	getch();
	return 0;
}